<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>abjad.mutate &mdash; Abjad 3.12 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/abjad.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/uqbar.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/lightbox2/css/lightbox.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="canonical" href="https://abjad.github.io_modules/abjad/mutate.html"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script defer="defer" src="../../_static/copybutton.js"></script>
        <script src="../../_static/ga.js"></script>
        <script defer="defer" src="../../_static/lightbox2/js/lightbox.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #66cc22" >


    <a href="../../index.html" class="icon icon-home" alt="Documentation
    Home"> Abjad 3.12



    <img src="../../_static/abjad-logo.png" class="logo" alt="Logo"/>

</a>




<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">First steps</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../first_steps/audience.html">Audience</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../first_steps/macos.html">macOS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../first_steps/linux.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../first_steps/windows.html">Windows</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview/containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/containers-basic-operations-on.html">Containers, basic operations on</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/containers-retrieving-by-name.html">Containers, retrieving by name</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/containers-time-interpretation-of.html">Containers, time interpretation of</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/contexts-lilypond-type-of.html">Contexts, LilyPond type of</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/indicators.html">Indicators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/lilypond-files-preamble-of.html">LilyPond files, preamble of</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview/lilypond-format-of-abjad-objects.html">LilyPond format, of Abjad objects</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/corpus-selection.html">Corpus, figure selection from</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/design-by-dyads.html">Design, by dyads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/enumeration.html">Enumeration, of rhythmic cells</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/magic-square-from-twelve-tone-row.html">Magic square, from twelve-tone row</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/scales-diatonic.html">Scales, diatonic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/score-fragment-piano.html">Score fragment, piano</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">All classes &amp; functions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Abjad API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/best-practices.html">Best practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/changes.html">Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/community.html">Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/developer-installation.html">Developer installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/lilypond-context-concatenation.html">LilyPond context concatenation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appendices/publications.html">Publications</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Score gallery</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gallery-2020.html">2020-16</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery-2015.html">2015-11</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery-2010.html">2010-00</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #66cc22" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Abjad</a>
      </nav>

      <div class="wy-nav-content">

<div class="rst-content">

    


    <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
    <div itemprop="articleBody">
    
  <h1>Source code for abjad.mutate</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">python_copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_getlib</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">bind</span> <span class="k">as</span> <span class="n">_bind</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">duration</span> <span class="k">as</span> <span class="n">_duration</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">enums</span> <span class="k">as</span> <span class="n">_enums</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">exceptions</span> <span class="k">as</span> <span class="n">_exceptions</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">get</span> <span class="k">as</span> <span class="n">_get</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">indicators</span> <span class="k">as</span> <span class="n">_indicators</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">iterate</span> <span class="k">as</span> <span class="n">_iterate</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">makers</span> <span class="k">as</span> <span class="n">_makers</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parentage</span> <span class="k">as</span> <span class="n">_parentage</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">pitch</span> <span class="k">as</span> <span class="n">_pitch</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ratio</span> <span class="k">as</span> <span class="n">_ratio</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">score</span> <span class="k">as</span> <span class="n">_score</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">select</span> <span class="k">as</span> <span class="n">_select</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">sequence</span> <span class="k">as</span> <span class="n">_sequence</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spanners</span> <span class="k">as</span> <span class="n">_spanners</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tag</span> <span class="k">as</span> <span class="n">_tag</span>


<span class="k">def</span> <span class="nf">_are_contiguous_logical_voice</span><span class="p">(</span>
    <span class="n">selection</span><span class="p">,</span> <span class="n">prototype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is true when items in selection are contiguous components in the same logical voice.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;4 d&#39;4 e&#39;4 f&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_logical_voice(staff[:])</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; staves = [staff[0], staff[-1]]</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_logical_voice(staves)</span>
<span class="sd">        False</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        REGRESSION. Before-grace music may be ignored:</span>

<span class="sd">        &gt;&gt;&gt; voice = abjad.Voice(&quot;c&#39;4 d&#39; e&#39; f&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.BeforeGraceContainer(&quot;cs&#39;16&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(container, voice[1])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(voice) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(voice)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Voice</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                \grace {</span>
<span class="sd">                    cs&#39;16</span>
<span class="sd">                }</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; voice[:]</span>
<span class="sd">        [Note(&quot;c&#39;4&quot;), Note(&quot;d&#39;4&quot;), Note(&quot;e&#39;4&quot;), Note(&quot;f&#39;4&quot;)]</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_logical_voice(voice[:])</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_logical_voice(</span>
<span class="sd">        ...     voice[:],</span>
<span class="sd">        ...     ignore_before_after_grace=True</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>

<span class="sd">        After-grace music may be ignored, too:</span>

<span class="sd">        &gt;&gt;&gt; voice = abjad.Voice(&quot;c&#39;4 d&#39; e&#39; f&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.AfterGraceContainer(&quot;cs&#39;16&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(container, voice[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(voice) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(voice)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Voice</span>
<span class="sd">            {</span>
<span class="sd">                \afterGrace</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                {</span>
<span class="sd">                    cs&#39;16</span>
<span class="sd">                }</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; voice[:]</span>
<span class="sd">        [Note(&quot;c&#39;4&quot;), Note(&quot;d&#39;4&quot;), Note(&quot;e&#39;4&quot;), Note(&quot;f&#39;4&quot;)]</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_logical_voice(voice[:])</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_logical_voice(</span>
<span class="sd">        ...     voice[:],</span>
<span class="sd">        ...     ignore_before_after_grace=True</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">prototype</span> <span class="o">=</span> <span class="n">prototype</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">,)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">prototype</span> <span class="o">=</span> <span class="p">(</span><span class="n">prototype</span><span class="p">,)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">prototype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">prototype</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">first_parentage</span> <span class="o">=</span> <span class="n">_parentage</span><span class="o">.</span><span class="n">Parentage</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
    <span class="n">first_logical_voice</span> <span class="o">=</span> <span class="n">first_parentage</span><span class="o">.</span><span class="n">logical_voice</span><span class="p">()</span>
    <span class="n">first_root</span> <span class="o">=</span> <span class="n">first_parentage</span><span class="o">.</span><span class="n">root</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">first</span>
    <span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">current_parentage</span> <span class="o">=</span> <span class="n">_parentage</span><span class="o">.</span><span class="n">Parentage</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="n">current_logical_voice</span> <span class="o">=</span> <span class="n">current_parentage</span><span class="o">.</span><span class="n">logical_voice</span><span class="p">()</span>
        <span class="c1"># false if wrong type of component found</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">prototype</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># false if in different logical voices</span>
        <span class="k">if</span> <span class="n">current_logical_voice</span> <span class="o">!=</span> <span class="n">first_logical_voice</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># false if components are in same score and are discontiguous</span>
        <span class="k">if</span> <span class="n">current_parentage</span><span class="o">.</span><span class="n">root</span> <span class="o">==</span> <span class="n">first_root</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_immediately_precedes</span><span class="p">(</span>
                <span class="n">previous</span><span class="p">,</span>
                <span class="n">current</span><span class="p">,</span>
                <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="n">ignore_before_after_grace</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_are_contiguous_same_parent</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">prototype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is true when items in selection are all contiguous components in the same parent.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;4 d&#39;4 e&#39;4 f&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_same_parent(staff[:])</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; staves = [staff[0], staff[-1]]</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_same_parent(staves)</span>
<span class="sd">        False</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        REGRESSION. Before-grace music music may be ignored:</span>

<span class="sd">        &gt;&gt;&gt; voice = abjad.Voice(&quot;c&#39;4 d&#39; e&#39; f&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.BeforeGraceContainer(&quot;cs&#39;16&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(container, voice[1])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(voice) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(voice)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Voice</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                \grace {</span>
<span class="sd">                    cs&#39;16</span>
<span class="sd">                }</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; voice[:]</span>
<span class="sd">        [Note(&quot;c&#39;4&quot;), Note(&quot;d&#39;4&quot;), Note(&quot;e&#39;4&quot;), Note(&quot;f&#39;4&quot;)]</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_same_parent(voice[:])</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_same_parent(</span>
<span class="sd">        ...     voice[:],</span>
<span class="sd">        ...     ignore_before_after_grace=True</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>

<span class="sd">        After-grace music may be ignored, too:</span>

<span class="sd">        &gt;&gt;&gt; voice = abjad.Voice(&quot;c&#39;4 d&#39; e&#39; f&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.AfterGraceContainer(&quot;cs&#39;16&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(container, voice[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(voice) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(voice)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Voice</span>
<span class="sd">            {</span>
<span class="sd">                \afterGrace</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                {</span>
<span class="sd">                    cs&#39;16</span>
<span class="sd">                }</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; voice[:]</span>
<span class="sd">        [Note(&quot;c&#39;4&quot;), Note(&quot;d&#39;4&quot;), Note(&quot;e&#39;4&quot;), Note(&quot;f&#39;4&quot;)]</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_same_parent(voice[:])</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate._are_contiguous_same_parent(</span>
<span class="sd">        ...     voice[:],</span>
<span class="sd">        ...     ignore_before_after_grace=True</span>
<span class="sd">        ... )</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prototype</span> <span class="o">=</span> <span class="n">prototype</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">,)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">prototype</span> <span class="o">=</span> <span class="p">(</span><span class="n">prototype</span><span class="p">,)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">prototype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">prototype</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">first_parent</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">_parent</span>
    <span class="n">same_parent</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">strictly_contiguous</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">first</span>
    <span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">prototype</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">first_parent</span><span class="p">:</span>
            <span class="n">same_parent</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_immediately_precedes</span><span class="p">(</span>
            <span class="n">previous</span><span class="p">,</span>
            <span class="n">current</span><span class="p">,</span>
            <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="n">ignore_before_after_grace</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">strictly_contiguous</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">same_parent</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">strictly_contiguous</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">current</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_attach_tie_to_leaves</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">(),</span> <span class="n">leaf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_copy_selection</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_logical_voice</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="n">new_components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">):</span>
            <span class="n">new_component</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">_copy_with_children</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_component</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
        <span class="n">new_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_component</span><span class="p">)</span>
    <span class="n">new_components</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">selection</span><span class="p">)(</span><span class="n">new_components</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_components</span>


<span class="k">def</span> <span class="nf">_extract</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="p">[</span><span class="n">component</span><span class="p">]</span>
    <span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">_get_parent_and_start_stop_indices</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="s2">&quot;components&quot;</span><span class="p">,</span> <span class="p">()))</span>
        <span class="n">parent</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">components</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">component</span>


<span class="k">def</span> <span class="nf">_fuse</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_logical_voice</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">components</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_fuse_leaves</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">components</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_fuse_tuplets</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can only fuse leaves and tuplets (not </span><span class="si">{</span><span class="n">components</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_fuse_leaves</span><span class="p">(</span><span class="n">leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_logical_voice</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">leaves</span>
    <span class="n">originally_tied</span> <span class="o">=</span> <span class="n">leaves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_has_indicator</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">)</span>
    <span class="n">total_preprolated</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">_get_preprolated_duration</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">parent</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_set_leaf_duration</span><span class="p">(</span><span class="n">leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">total_preprolated</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">originally_tied</span><span class="p">:</span>
        <span class="n">last_leaf</span> <span class="o">=</span> <span class="n">_select</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">,</span> <span class="n">last_leaf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_fuse_leaves_by_immediate_parent</span><span class="p">(</span><span class="n">leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">_get_leaves_grouped_by_immediate_parents</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">:</span>
        <span class="n">fused</span> <span class="o">=</span> <span class="n">_fuse</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fused</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_fuse_tuplets</span><span class="p">(</span><span class="n">tuplets</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span><span class="n">tuplets</span><span class="p">,</span> <span class="n">prototype</span><span class="o">=</span><span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tuplets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">tuplets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">first_multiplier</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">multiplier</span>
    <span class="k">for</span> <span class="n">tuplet</span> <span class="ow">in</span> <span class="n">tuplets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">tuplet</span><span class="o">.</span><span class="n">multiplier</span> <span class="o">!=</span> <span class="n">first_multiplier</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tuplets must carry same multiplier.&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">)</span>
    <span class="n">new_tuplet</span> <span class="o">=</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">(</span><span class="n">first_multiplier</span><span class="p">,</span> <span class="p">[],</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">wrapped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">tuplets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">tuplets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
        <span class="n">dummy_container</span> <span class="o">=</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">(</span><span class="n">tuplets</span><span class="p">)</span>
        <span class="n">wrapped</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">tuplets</span><span class="p">,</span> <span class="n">new_tuplet</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">wrapped</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">dummy_container</span><span class="p">[:]</span>
    <span class="k">return</span> <span class="n">new_tuplet</span>


<span class="k">def</span> <span class="nf">_get_leaves_grouped_by_immediate_parents</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pairs_generator</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">leaves</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">id</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">_parent</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values_generator</span> <span class="ow">in</span> <span class="n">pairs_generator</span><span class="p">:</span>
        <span class="n">group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values_generator</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_give_components_to_empty_container</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">container</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
        <span class="n">components</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="s2">&quot;components&quot;</span><span class="p">,</span> <span class="p">()))</span>
    <span class="n">container</span><span class="o">.</span><span class="n">_components</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
    <span class="n">_set_parents</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_parent_and_start_stop_indices</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span>
        <span class="n">selection</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="n">ignore_before_after_grace</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">selection</span><span class="p">:</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">selection</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">first_index</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
            <span class="n">last_index</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">parent</span><span class="p">,</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">last_index</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_give_position_in_parent_to_container</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
    <span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">_get_parent_and_start_stop_indices</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">_components</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="p">[</span><span class="n">container</span><span class="p">])</span>
        <span class="n">container</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
            <span class="n">component</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_immediately_precedes</span><span class="p">(</span><span class="n">component_1</span><span class="p">,</span> <span class="n">component_2</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">successors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">component_1</span>
    <span class="c1"># do not include OnBeatGraceContainer here because</span>
    <span class="c1"># OnBeatGraceContainer is a proper container</span>
    <span class="n">grace_prototype</span> <span class="o">=</span> <span class="p">(</span><span class="n">_score</span><span class="o">.</span><span class="n">AfterGraceContainer</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">BeforeGraceContainer</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sibling</span> <span class="o">=</span> <span class="n">_getlib</span><span class="o">.</span><span class="n">_get_sibling_with_graces</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">while</span> <span class="p">(</span>
            <span class="n">ignore_before_after_grace</span>
            <span class="ow">and</span> <span class="n">sibling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sibling</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">grace_prototype</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">sibling</span> <span class="o">=</span> <span class="n">_getlib</span><span class="o">.</span><span class="n">_get_sibling_with_graces</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sibling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">descendants</span> <span class="o">=</span> <span class="n">sibling</span><span class="o">.</span><span class="n">_get_descendants_starting_with</span><span class="p">()</span>
            <span class="n">successors</span> <span class="o">=</span> <span class="n">descendants</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">component_2</span> <span class="ow">in</span> <span class="n">successors</span>


<span class="k">def</span> <span class="nf">_move_indicators</span><span class="p">(</span><span class="n">donor_component</span><span class="p">,</span> <span class="n">recipient_component</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">_get</span><span class="o">.</span><span class="n">wrappers</span><span class="p">(</span><span class="n">donor_component</span><span class="p">):</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">donor_component</span><span class="p">)</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">recipient_component</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_set_leaf_duration</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">new_duration</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">new_duration</span> <span class="o">=</span> <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">new_duration</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">multiplier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">new_duration</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">leaf</span><span class="o">.</span><span class="n">written_duration</span><span class="p">)</span>
        <span class="n">leaf</span><span class="o">.</span><span class="n">multiplier</span> <span class="o">=</span> <span class="n">multiplier</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">leaf</span><span class="o">.</span><span class="n">written_duration</span> <span class="o">=</span> <span class="n">new_duration</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
    <span class="k">except</span> <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssignabilityError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">_makers</span><span class="o">.</span><span class="n">make_notes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_duration</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">new_leaves</span> <span class="o">=</span> <span class="n">_select</span><span class="o">.</span><span class="n">leaves</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
    <span class="n">following_leaf_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_leaves</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">following_leaves</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">following_leaf_count</span><span class="p">):</span>
        <span class="n">following_leaf</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">indicator</span> <span class="ow">in</span> <span class="n">_get</span><span class="o">.</span><span class="n">indicators</span><span class="p">(</span><span class="n">following_leaf</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">following_leaf_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="s2">&quot;_time_orientation&quot;</span><span class="p">,</span> <span class="n">_enums</span><span class="o">.</span><span class="n">LEFT</span><span class="p">)</span>
                    <span class="o">!=</span> <span class="n">_enums</span><span class="o">.</span><span class="n">MIDDLE</span>
                <span class="p">):</span>
                    <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">following_leaf</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="s2">&quot;_time_orientation&quot;</span><span class="p">,</span> <span class="n">_enums</span><span class="o">.</span><span class="n">LEFT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_enums</span><span class="o">.</span><span class="n">RIGHT</span>
                <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="s2">&quot;_time_orientation&quot;</span><span class="p">,</span> <span class="n">_enums</span><span class="o">.</span><span class="n">LEFT</span><span class="p">)</span>
                <span class="o">!=</span> <span class="n">_enums</span><span class="o">.</span><span class="n">MIDDLE</span>
            <span class="p">):</span>
                <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">following_leaf</span><span class="p">)</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_score</span><span class="o">.</span><span class="n">BeforeGraceContainer</span><span class="p">,</span> <span class="n">following_leaf</span><span class="p">)</span>
        <span class="n">following_leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">following_leaf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">following_leaf_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">indicator</span> <span class="ow">in</span> <span class="n">_get</span><span class="o">.</span><span class="n">indicators</span><span class="p">(</span><span class="n">leaf</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="s2">&quot;_time_orientation&quot;</span><span class="p">,</span> <span class="n">_enums</span><span class="o">.</span><span class="n">LEFT</span><span class="p">)</span> <span class="o">==</span> <span class="n">_enums</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span>
                <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
    <span class="n">all_leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span> <span class="o">+</span> <span class="n">following_leaves</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_leaves</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_leaves</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">all_leaf</span><span class="p">,</span> <span class="n">new_leaf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_leaves</span><span class="p">,</span> <span class="n">new_leaves</span><span class="p">):</span>
        <span class="n">all_leaf</span><span class="o">.</span><span class="n">written_duration</span> <span class="o">=</span> <span class="n">new_leaf</span><span class="o">.</span><span class="n">written_duration</span>
    <span class="n">logical_tie</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">logical_tie</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
    <span class="n">logical_tie_leaves</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">logical_tie</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">leaf_</span> <span class="ow">in</span> <span class="n">logical_tie</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">,</span> <span class="n">leaf_</span><span class="p">)</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">RepeatTie</span><span class="p">,</span> <span class="n">leaf_</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">leaf</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">next_</span><span class="p">:</span><span class="n">next_</span><span class="p">]</span> <span class="o">=</span> <span class="n">following_leaves</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">logical_tie_leaves</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
    <span class="n">next_</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">logical_tie_leaves</span><span class="p">[</span><span class="n">next_</span><span class="p">:</span><span class="n">next_</span><span class="p">]</span> <span class="o">=</span> <span class="n">following_leaves</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">logical_tie_leaves</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Note</span> <span class="o">|</span> <span class="n">_score</span><span class="o">.</span><span class="n">Chord</span><span class="p">):</span>
        <span class="n">_spanners</span><span class="o">.</span><span class="n">tie</span><span class="p">(</span><span class="n">logical_tie_leaves</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_leaves</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_leaves</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">tuplet</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">tuplet</span><span class="o">.</span><span class="n">multiplier</span>
        <span class="n">tuplet</span> <span class="o">=</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">(</span><span class="n">multiplier</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">all_leaves</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="n">wrap</span><span class="p">(</span><span class="n">all_leaves</span><span class="p">,</span> <span class="n">tuplet</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tuplet</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_set_parents</span><span class="p">(</span><span class="n">container</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">container</span><span class="p">:</span>
        <span class="n">component</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_split_container_at_index</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits container to the left of index ``i``.</span>

<span class="sd">    Preserves tuplet multiplier when container is a tuplet.</span>

<span class="sd">    Preserves time signature denominator when container is a measure.</span>

<span class="sd">    Resizes resizable containers.</span>


<span class="sd">    Returns split parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># partition my components</span>
    <span class="n">left_components</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
    <span class="n">right_components</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
    <span class="c1"># instantiate new left and right containers</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">):</span>
        <span class="n">multiplier</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">multiplier</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">)(</span><span class="n">multiplier</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">wrap</span><span class="p">(</span><span class="n">left_components</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">)(</span><span class="n">multiplier</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">wrap</span><span class="p">(</span><span class="n">right_components</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
        <span class="n">wrap</span><span class="p">(</span><span class="n">left_components</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
        <span class="n">wrap</span><span class="p">(</span><span class="n">right_components</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="c1"># save left and right containers together for iteration</span>
    <span class="n">halves</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="n">nonempty_halves</span> <span class="o">=</span> <span class="p">[</span><span class="n">half</span> <span class="k">for</span> <span class="n">half</span> <span class="ow">in</span> <span class="n">halves</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">half</span><span class="p">)]</span>
    <span class="c1"># incorporate left and right parents in score if possible</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="p">[</span><span class="n">CONTAINER</span><span class="p">]</span>
    <span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">_get_parent_and_start_stop_indices</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">_components</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nonempty_halves</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">nonempty_halves</span><span class="p">:</span>
            <span class="n">part</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">right</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># return new left and right containers</span>
    <span class="k">return</span> <span class="n">halves</span>


<span class="k">def</span> <span class="nf">_split_container_by_duration</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">simultaneous</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_split_simultaneous_by_duration</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">duration</span> <span class="o">=</span> <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">duration</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">duration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO: disallow and raise Exception</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="n">CONTAINER</span>
    <span class="c1"># get split point score offset</span>
    <span class="n">timespan</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">timespan</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">)</span>
    <span class="n">global_split_point</span> <span class="o">=</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start_offset</span> <span class="o">+</span> <span class="n">duration</span>
    <span class="c1"># get any duration-crossing descendents</span>
    <span class="n">cross_offset</span> <span class="o">=</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start_offset</span> <span class="o">+</span> <span class="n">duration</span>
    <span class="n">duration_crossing_descendants</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">descendant</span> <span class="ow">in</span> <span class="n">_get</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">):</span>
        <span class="n">timespan</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">timespan</span><span class="p">(</span><span class="n">descendant</span><span class="p">)</span>
        <span class="n">start_offset</span> <span class="o">=</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start_offset</span>
        <span class="n">stop_offset</span> <span class="o">=</span> <span class="n">timespan</span><span class="o">.</span><span class="n">stop_offset</span>
        <span class="k">if</span> <span class="n">start_offset</span> <span class="o">&lt;</span> <span class="n">cross_offset</span> <span class="o">&lt;</span> <span class="n">stop_offset</span><span class="p">:</span>
            <span class="n">duration_crossing_descendants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">descendant</span><span class="p">)</span>
    <span class="c1"># any duration-crossing leaf will be at end of list</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="n">duration_crossing_descendants</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">did_split_leaf</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># if split point necessitates leaf split</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">)</span>
        <span class="n">original_bottom_parent</span> <span class="o">=</span> <span class="n">bottom</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">did_split_leaf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">timespan</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">timespan</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
        <span class="n">split_point_in_bottom</span> <span class="o">=</span> <span class="n">global_split_point</span> <span class="o">-</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start_offset</span>
        <span class="n">new_leaves</span> <span class="o">=</span> <span class="n">_split_leaf_by_durations</span><span class="p">(</span>
            <span class="n">bottom</span><span class="p">,</span>
            <span class="p">[</span><span class="n">split_point_in_bottom</span><span class="p">],</span>
            <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">new_leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">original_bottom_parent</span><span class="p">:</span>
            <span class="n">new_leaves_tuplet_wrapper</span> <span class="o">=</span> <span class="n">new_leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parent</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_leaves_tuplet_wrapper</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">new_leaves_tuplet_wrapper</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="n">original_bottom_parent</span>
            <span class="n">_split_container_by_duration</span><span class="p">(</span>
                <span class="n">new_leaves_tuplet_wrapper</span><span class="p">,</span>
                <span class="n">split_point_in_bottom</span><span class="p">,</span>
                <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">new_leaves</span><span class="p">:</span>
            <span class="n">timespan</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">timespan</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timespan</span><span class="o">.</span><span class="n">stop_offset</span> <span class="o">==</span> <span class="n">global_split_point</span><span class="p">:</span>
                <span class="n">leaf_left_of_split</span> <span class="o">=</span> <span class="n">leaf</span>
            <span class="k">if</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start_offset</span> <span class="o">==</span> <span class="n">global_split_point</span><span class="p">:</span>
                <span class="n">leaf_right_of_split</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="n">duration_crossing_containers</span> <span class="o">=</span> <span class="n">duration_crossing_descendants</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">duration_crossing_containers</span><span class="p">)</span>
    <span class="c1"># if split point falls between leaves</span>
    <span class="c1"># then find leaf to immediate right of split point</span>
    <span class="c1"># in order to start upward crawl through duration-crossing containers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">duration_crossing_containers</span> <span class="o">=</span> <span class="n">duration_crossing_descendants</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">_iterate</span><span class="o">.</span><span class="n">leaves</span><span class="p">(</span><span class="n">bottom</span><span class="p">):</span>
            <span class="n">timespan</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">timespan</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timespan</span><span class="o">.</span><span class="n">start_offset</span> <span class="o">==</span> <span class="n">global_split_point</span><span class="p">:</span>
                <span class="n">leaf_right_of_split</span> <span class="o">=</span> <span class="n">leaf</span>
                <span class="n">leaf_left_of_split</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;can not split empty container </span><span class="si">{bottom!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">leaf_left_of_split</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="n">leaf_right_of_split</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># find component to right of split</span>
    <span class="c1"># that is also immediate child of last duration-crossing container</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">leaf_right_of_split</span><span class="o">.</span><span class="n">_get_parentage</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">component</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="n">duration_crossing_containers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">highest_level_component_right_of_split</span> <span class="o">=</span> <span class="n">component</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should not be able to get here.&quot;</span><span class="p">)</span>
    <span class="c1"># crawl back up through duration-crossing containers and split each</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">highest_level_component_right_of_split</span>
    <span class="k">for</span> <span class="n">container</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">duration_crossing_containers</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">_split_container_at_index</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">right</span>
    <span class="c1"># reapply tie here if crawl above killed tie applied to leaves</span>
    <span class="k">if</span> <span class="n">did_split_leaf</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf_left_of_split</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Note</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">leaf_left_of_split</span><span class="p">)</span><span class="o">.</span><span class="n">root</span>
                <span class="ow">is</span> <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">leaf_right_of_split</span><span class="p">)</span><span class="o">.</span><span class="n">root</span>
            <span class="p">):</span>
                <span class="n">leaves_around_split</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">leaf_left_of_split</span><span class="p">,</span>
                    <span class="n">leaf_right_of_split</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">_attach_tie_to_leaves</span><span class="p">(</span><span class="n">leaves_around_split</span><span class="p">)</span>
    <span class="c1"># return list-wrapped halves of container</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="p">[</span><span class="n">right</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_split_simultaneous_by_duration</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">simultaneous</span>
    <span class="n">left_components</span><span class="p">,</span> <span class="n">right_components</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">CONTAINER</span><span class="p">[:]:</span>
        <span class="n">halves</span> <span class="o">=</span> <span class="n">_split_container_by_duration</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
        <span class="n">left_components_</span><span class="p">,</span> <span class="n">right_components_</span> <span class="o">=</span> <span class="n">halves</span>
        <span class="n">left_components</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left_components_</span><span class="p">)</span>
        <span class="n">right_components</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">right_components_</span><span class="p">)</span>
    <span class="n">left_container</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
    <span class="n">right_container</span> <span class="o">=</span> <span class="n">CONTAINER</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
    <span class="n">left_container</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left_components</span><span class="p">)</span>
    <span class="n">right_container</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">right_components</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">containers</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_container</span><span class="p">,</span> <span class="n">right_container</span><span class="p">]</span>
        <span class="n">replace</span><span class="p">(</span><span class="n">CONTAINER</span><span class="p">,</span> <span class="n">containers</span><span class="p">)</span>
    <span class="c1"># return list-wrapped halves of container</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">left_container</span><span class="p">],</span> <span class="p">[</span><span class="n">right_container</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_split_leaf_by_durations</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">cyclic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">durations</span><span class="p">]</span>
    <span class="n">leaf_duration</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">duration</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cyclic</span><span class="p">:</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">repeat_to_weight</span><span class="p">(</span><span class="n">durations</span><span class="p">,</span> <span class="n">leaf_duration</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">leaf_duration</span><span class="p">:</span>
        <span class="n">last_duration</span> <span class="o">=</span> <span class="n">leaf_duration</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
        <span class="n">durations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_duration</span><span class="p">)</span>
    <span class="n">durations</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">durations</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">leaf_duration</span><span class="p">)</span>
    <span class="n">originally_tied</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_has_indicator</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">)</span>
    <span class="n">originally_repeat_tied</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_has_indicator</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">RepeatTie</span><span class="p">)</span>
    <span class="n">result_selections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># detach grace containers</span>
    <span class="n">before_grace_container</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_before_grace_container</span>
    <span class="k">if</span> <span class="n">before_grace_container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">before_grace_container</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
    <span class="n">after_grace_container</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">.</span><span class="n">_after_grace_container</span>
    <span class="k">if</span> <span class="n">after_grace_container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">after_grace_container</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
    <span class="c1"># do other things</span>
    <span class="n">leaf_prolation</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span><span class="o">.</span><span class="n">prolation</span>
    <span class="k">for</span> <span class="n">duration</span> <span class="ow">in</span> <span class="n">durations</span><span class="p">:</span>
        <span class="n">new_leaf</span> <span class="o">=</span> <span class="n">python_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
        <span class="n">preprolated_duration</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">/</span> <span class="n">leaf_prolation</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">_set_leaf_duration</span><span class="p">(</span><span class="n">new_leaf</span><span class="p">,</span> <span class="n">preprolated_duration</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
        <span class="n">result_selections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="n">result_components</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">result_selections</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">result_leaves</span> <span class="o">=</span> <span class="n">_select</span><span class="o">.</span><span class="n">leaves</span><span class="p">(</span><span class="n">result_components</span><span class="p">,</span> <span class="n">grace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result_components</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result_leaves</span><span class="p">)</span>
    <span class="c1"># strip result leaves of all indicators</span>
    <span class="k">for</span> <span class="n">leaf_</span> <span class="ow">in</span> <span class="n">result_leaves</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">leaf_</span><span class="p">)</span>
    <span class="c1"># replace leaf with flattened result</span>
    <span class="k">if</span> <span class="n">_get</span><span class="o">.</span><span class="n">parentage</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">replace</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">result_components</span><span class="p">)</span>
    <span class="c1"># move indicators</span>
    <span class="n">first_result_leaf</span> <span class="o">=</span> <span class="n">result_leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_result_leaf</span> <span class="o">=</span> <span class="n">result_leaves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">indicator</span> <span class="ow">in</span> <span class="n">_get</span><span class="o">.</span><span class="n">indicators</span><span class="p">(</span><span class="n">leaf</span><span class="p">):</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="s2">&quot;_time_orientation&quot;</span><span class="p">,</span> <span class="n">_enums</span><span class="o">.</span><span class="n">LEFT</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="n">_enums</span><span class="o">.</span><span class="n">LEFT</span><span class="p">:</span>
            <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">first_result_leaf</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">_enums</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span>
            <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">last_result_leaf</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">_enums</span><span class="o">.</span><span class="n">MIDDLE</span><span class="p">:</span>
            <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">indicator</span><span class="p">,</span> <span class="n">first_result_leaf</span><span class="p">)</span>
            <span class="n">indicator_copy</span> <span class="o">=</span> <span class="n">python_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">indicator</span><span class="p">)</span>
            <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">indicator_copy</span><span class="p">,</span> <span class="n">last_result_leaf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="c1"># reattach grace containers</span>
    <span class="k">if</span> <span class="n">before_grace_container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">before_grace_container</span><span class="p">,</span> <span class="n">first_result_leaf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">after_grace_container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">after_grace_container</span><span class="p">,</span> <span class="n">last_result_leaf</span><span class="p">)</span>
    <span class="c1"># fuse tuplets</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result_components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">):</span>
        <span class="n">fuse</span><span class="p">(</span><span class="n">result_components</span><span class="p">)</span>
    <span class="c1"># tie split notes</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Note</span> <span class="o">|</span> <span class="n">_score</span><span class="o">.</span><span class="n">Chord</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_leaves</span><span class="p">):</span>
        <span class="n">_attach_tie_to_leaves</span><span class="p">(</span><span class="n">result_leaves</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">originally_repeat_tied</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result_leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_has_indicator</span><span class="p">(</span>
        <span class="n">_indicators</span><span class="o">.</span><span class="n">RepeatTie</span>
    <span class="p">):</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">RepeatTie</span><span class="p">(),</span> <span class="n">result_leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">originally_tied</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result_leaves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_has_indicator</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">):</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">attach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">(),</span> <span class="n">result_leaves</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result_leaves</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result_leaves</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_leaves</span>


<div class="viewcode-block" id="copy"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.copy">[docs]</a><span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies argument.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Copies explicit clefs:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;8 cs&#39;8 d&#39;8 ef&#39;8 e&#39;8 f&#39;8 fs&#39;8 g&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; clef = abjad.Clef(&#39;treble&#39;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(clef, staff[0])</span>
<span class="sd">        &gt;&gt;&gt; clef = abjad.Clef(&#39;bass&#39;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(clef, staff[4])</span>
<span class="sd">        &gt;&gt;&gt; copied_notes = abjad.mutate.copy(staff[:2])</span>
<span class="sd">        &gt;&gt;&gt; staff.extend(copied_notes)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \clef &quot;treble&quot;</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                cs&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                ef&#39;8</span>
<span class="sd">                \clef &quot;bass&quot;</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                fs&#39;8</span>
<span class="sd">                g&#39;8</span>
<span class="sd">                \clef &quot;treble&quot;</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                cs&#39;8</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Does not copy implicit clefs:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;8 cs&#39;8 d&#39;8 ef&#39;8 e&#39;8 f&#39;8 fs&#39;8 g&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; clef = abjad.Clef(&#39;treble&#39;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(clef, staff[0])</span>
<span class="sd">        &gt;&gt;&gt; clef = abjad.Clef(&#39;bass&#39;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(clef, staff[4])</span>
<span class="sd">        &gt;&gt;&gt; copied_notes = abjad.mutate.copy(staff[2:4])</span>
<span class="sd">        &gt;&gt;&gt; staff.extend(copied_notes)</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \clef &quot;treble&quot;</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                cs&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                ef&#39;8</span>
<span class="sd">                \clef &quot;bass&quot;</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                fs&#39;8</span>
<span class="sd">                g&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                ef&#39;8</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Copy components one time:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(r&quot;c&#39;8 d&#39;8 e&#39;8 f&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; staff.extend(r&quot;g&#39;8 a&#39;8 b&#39;8 c&#39;&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((2, 4))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 2/4</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                g&#39;8</span>
<span class="sd">                a&#39;8</span>
<span class="sd">                b&#39;8</span>
<span class="sd">                c&#39;&#39;8</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; selection = staff[2:4]</span>
<span class="sd">        &gt;&gt;&gt; result = abjad.mutate.copy(selection)</span>
<span class="sd">        &gt;&gt;&gt; new_staff = abjad.Staff(result)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(new_staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(new_staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; staff[2] is new_staff[0]</span>
<span class="sd">        False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[</span><span class="n">argument</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">argument</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_copy_selection</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">result_</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="eject_contents"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.eject_contents">[docs]</a><span class="k">def</span> <span class="nf">eject_contents</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ejects ``container`` contents.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Ejects leaves from container:</span>

<span class="sd">        &gt;&gt;&gt; container = abjad.Container(&quot;c&#39;4 ~ c&#39;4 d&#39;4 ~ d&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(container) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(container)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; leaves = abjad.mutate.eject_contents(container)</span>
<span class="sd">        &gt;&gt;&gt; leaves</span>
<span class="sd">        [Note(&quot;c&#39;4&quot;), Note(&quot;c&#39;4&quot;), Note(&quot;d&#39;4&quot;), Note(&quot;d&#39;4&quot;)]</span>

<span class="sd">        Leaves can be added to a new container:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(leaves, lilypond_type=&quot;RhythmicStaff&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new RhythmicStaff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        Old container is empty:</span>

<span class="sd">        &gt;&gt;&gt; container</span>
<span class="sd">        Container()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">container</span><span class="p">[:]</span>
    <span class="n">container</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">components</span></div>


<div class="viewcode-block" id="extract"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.extract">[docs]</a><span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">argument</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts ``argument`` from score.</span>

<span class="sd">    Leaves children of ``argument`` in score.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Extract tuplets:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff()</span>
<span class="sd">        &gt;&gt;&gt; staff.append(abjad.Tuplet((3, 2), &quot;c&#39;4 e&#39;4&quot;))</span>
<span class="sd">        &gt;&gt;&gt; staff.append(abjad.Tuplet((3, 2), &quot;d&#39;4 f&#39;4&quot;))</span>
<span class="sd">        &gt;&gt;&gt; leaves = abjad.select.leaves(staff)</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((3, 4))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, leaves[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, leaves)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">                \times 3/2</span>
<span class="sd">                {</span>
<span class="sd">                    \time 3/4</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                }</span>
<span class="sd">                \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">                \times 3/2</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; empty_tuplet = abjad.mutate.extract(staff[-1])</span>
<span class="sd">        &gt;&gt;&gt; empty_tuplet = abjad.mutate.extract(staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 3/4</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                \f</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Scales tuplet contents and then extracts tuplet:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff()</span>
<span class="sd">        &gt;&gt;&gt; staff.append(abjad.Tuplet((3, 2), &quot;c&#39;4 e&#39;4&quot;))</span>
<span class="sd">        &gt;&gt;&gt; staff.append(abjad.Tuplet((3, 2), &quot;d&#39;4 f&#39;4&quot;))</span>
<span class="sd">        &gt;&gt;&gt; leaves = abjad.select.leaves(staff)</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, leaves)</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((3, 4))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, leaves[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">                \times 3/2</span>
<span class="sd">                {</span>
<span class="sd">                    \time 3/4</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                }</span>
<span class="sd">                \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">                \times 3/2</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.scale(staff[-1], abjad.Multiplier((3, 2)))</span>
<span class="sd">        &gt;&gt;&gt; empty_tuplet = abjad.mutate.extract(staff[-1])</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.scale(staff[0], abjad.Multiplier((3, 2)))</span>
<span class="sd">        &gt;&gt;&gt; empty_tuplet = abjad.mutate.extract(staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 3/4</span>
<span class="sd">                c&#39;4.</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                e&#39;4.</span>
<span class="sd">                d&#39;4.</span>
<span class="sd">                f&#39;4.</span>
<span class="sd">                \f</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Extracting out-of-score component does nothing and returns</span>
<span class="sd">        component:</span>

<span class="sd">        &gt;&gt;&gt; tuplet = abjad.Tuplet((3, 2), &quot;c&#39;4 e&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(tuplet) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(tuplet)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">            \times 3/2</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.extract(tuplet)</span>
<span class="sd">        Tuplet(&#39;2:3&#39;, &quot;c&#39;4 e&#39;4&quot;)</span>

<span class="sd">        &gt;&gt;&gt; abjad.show(tuplet) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(tuplet)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">            \times 3/2</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">            }</span>

<span class="sd">    Returns ``argument``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span></div>


<div class="viewcode-block" id="fuse"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.fuse">[docs]</a><span class="k">def</span> <span class="nf">fuse</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fuses ``argument``.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Fuses in-score leaves:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;8 d&#39;8 e&#39;8 f&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.fuse(staff[1:])</span>
<span class="sd">        [Note(&quot;d&#39;4.&quot;)]</span>

<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                d&#39;4.</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Fuses parent-contiguous tuplets in selection:</span>

<span class="sd">        &gt;&gt;&gt; tuplet_1 = abjad.Tuplet((2, 3), &quot;c&#39;8 d&#39; e&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.beam(tuplet_1[:])</span>
<span class="sd">        &gt;&gt;&gt; tuplet_2 = abjad.Tuplet((2, 3), &quot;c&#39;16 d&#39; e&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.slur(tuplet_2[:])</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff([tuplet_1, tuplet_2])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    [</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                    e&#39;8</span>
<span class="sd">                    ]</span>
<span class="sd">                }</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;16</span>
<span class="sd">                    (</span>
<span class="sd">                    d&#39;16</span>
<span class="sd">                    e&#39;16</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; tuplets = staff[:]</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.fuse(tuplets)</span>
<span class="sd">        Tuplet(&#39;3:2&#39;, &quot;c&#39;8 d&#39;8 e&#39;8 c&#39;16 d&#39;16 e&#39;16&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) #doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    [</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                    e&#39;8</span>
<span class="sd">                    ]</span>
<span class="sd">                    c&#39;16</span>
<span class="sd">                    (</span>
<span class="sd">                    d&#39;16</span>
<span class="sd">                    e&#39;16</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        Returns new tuplet in selection.</span>

<span class="sd">        Fuses zero or more parent-contiguous ``tuplets``.</span>

<span class="sd">        Allows in-score ``tuplets``.</span>

<span class="sd">        Allows outside-of-score ``tuplets``.</span>

<span class="sd">        All ``tuplets`` must carry the same multiplier.</span>

<span class="sd">        All ``tuplets`` must be of the same type.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        REGRESSION. Trims tie from fused note:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;d&#39;8 ~ d&#39;32 ~ d&#39;16 d&#39;32&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;32</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;16</span>
<span class="sd">                d&#39;32</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; logical_tie = abjad.select.logical_tie(staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.fuse(logical_tie)</span>
<span class="sd">        [Note(&quot;d&#39;8..&quot;)]</span>

<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                d&#39;8..</span>
<span class="sd">                d&#39;32</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.get.has_indicator(staff[0], abjad.Tie)</span>
<span class="sd">        False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_are_contiguous_logical_voice</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_fuse</span><span class="p">([</span><span class="n">argument</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_fuse</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">argument</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="logical_tie_to_tuplet"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.logical_tie_to_tuplet">[docs]</a><span class="k">def</span> <span class="nf">logical_tie_to_tuplet</span><span class="p">(</span>
    <span class="n">argument</span><span class="p">,</span> <span class="n">proportions</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="n">_tag</span><span class="o">.</span><span class="n">Tag</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes logical tie to tuplet.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(r&quot;df&#39;8 c&#39;8 ~ c&#39;16 cqs&#39;&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Dynamic(&#39;p&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.StartHairpin(&#39;&lt;&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Dynamic(&#39;f&#39;), staff[-1])</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(staff).DynamicLineSpanner.staff_padding = 3</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((9, 16))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                \time 9/16</span>
<span class="sd">                df&#39;8</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;16</span>
<span class="sd">                cqs&#39;&#39;4</span>
<span class="sd">                \f</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; logical_tie = abjad.select.logical_tie(staff[1])</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.logical_tie_to_tuplet(logical_tie, [2, 1, 1, 1])</span>
<span class="sd">        Tuplet(&#39;5:3&#39;, &quot;c&#39;8 c&#39;16 c&#39;16 c&#39;16&quot;)</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                \time 9/16</span>
<span class="sd">                df&#39;8</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                \tweak text #tuplet-number::calc-fraction-text</span>
<span class="sd">                \times 3/5</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    c&#39;16</span>
<span class="sd">                    c&#39;16</span>
<span class="sd">                    c&#39;16</span>
<span class="sd">                }</span>
<span class="sd">                cqs&#39;&#39;4</span>
<span class="sd">                \f</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(r&quot;c&#39;8 ~ c&#39;16 cqs&#39;&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, staff[:])</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(staff).DynamicLineSpanner.staff_padding = 3</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((7, 16))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                \time 7/16</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;16</span>
<span class="sd">                cqs&#39;&#39;4</span>
<span class="sd">                \f</span>
<span class="sd">            }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">proportions</span> <span class="o">=</span> <span class="n">_ratio</span><span class="o">.</span><span class="n">Ratio</span><span class="p">(</span><span class="n">proportions</span><span class="p">)</span>
    <span class="n">target_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">_get_preprolated_duration</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">argument</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_duration</span><span class="p">,</span> <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span>
    <span class="n">prolated_duration</span> <span class="o">=</span> <span class="n">target_duration</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proportions</span><span class="o">.</span><span class="n">numbers</span><span class="p">)</span>
    <span class="n">basic_written_duration</span> <span class="o">=</span> <span class="n">prolated_duration</span><span class="o">.</span><span class="n">equal_or_greater_power_of_two</span>
    <span class="n">written_durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="o">*</span> <span class="n">basic_written_duration</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">proportions</span><span class="o">.</span><span class="n">numbers</span><span class="p">]</span>
    <span class="n">notes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_score</span><span class="o">.</span><span class="n">Note</span> <span class="o">|</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">notes</span> <span class="o">=</span> <span class="p">[</span><span class="n">_score</span><span class="o">.</span><span class="n">Note</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">written_durations</span><span class="p">]</span>
    <span class="k">except</span> <span class="n">_exceptions</span><span class="o">.</span><span class="n">AssignabilityError</span><span class="p">:</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">target_duration</span><span class="o">.</span><span class="n">_denominator</span>
        <span class="n">note_durations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">proportions</span><span class="o">.</span><span class="n">numbers</span>
        <span class="p">]</span>
        <span class="n">notes</span> <span class="o">=</span> <span class="n">_makers</span><span class="o">.</span><span class="n">make_notes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">note_durations</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="n">tuplet</span> <span class="o">=</span> <span class="n">_score</span><span class="o">.</span><span class="n">Tuplet</span><span class="o">.</span><span class="n">from_duration</span><span class="p">(</span><span class="n">target_duration</span><span class="p">,</span> <span class="n">notes</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">argument</span><span class="p">:</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">Tie</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
        <span class="n">_bind</span><span class="o">.</span><span class="n">detach</span><span class="p">(</span><span class="n">_indicators</span><span class="o">.</span><span class="n">RepeatTie</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span>
    <span class="n">replace</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">tuplet</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tuplet</span></div>


<div class="viewcode-block" id="replace"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.replace">[docs]</a><span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">recipients</span><span class="p">,</span> <span class="n">wrappers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces ``argument`` (and contents of ``argument``) with ``recipients``.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Replaces in-score tuplet (and children of tuplet) with notes.</span>
<span class="sd">        Functions exactly the same as container setitem:</span>

<span class="sd">        &gt;&gt;&gt; tuplet_1 = abjad.Tuplet((2, 3), &quot;c&#39;4 d&#39;4 e&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tuplet_2 = abjad.Tuplet((2, 3), &quot;d&#39;4 e&#39;4 f&#39;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff([tuplet_1, tuplet_2])</span>
<span class="sd">        &gt;&gt;&gt; leaves = abjad.select.leaves(staff)</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, leaves)</span>
<span class="sd">        &gt;&gt;&gt; abjad.slur(leaves)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    (</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                }</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; notes = abjad.makers.make_notes(&quot;c&#39; d&#39; e&#39; f&#39; c&#39; d&#39; e&#39; f&#39;&quot;, (1, 16))</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.replace([tuplet_1], notes)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Dynamic(&#39;p&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.StartHairpin(&#39;&lt;&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;16</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                d&#39;16</span>
<span class="sd">                e&#39;16</span>
<span class="sd">                f&#39;16</span>
<span class="sd">                c&#39;16</span>
<span class="sd">                d&#39;16</span>
<span class="sd">                e&#39;16</span>
<span class="sd">                f&#39;16</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        Preserves both hairpin and slur.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Copies no wrappers when ``wrappers`` is false:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;2 f&#39;4 g&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Clef(&#39;alto&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \clef &quot;alto&quot;</span>
<span class="sd">                c&#39;2</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                g&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; for leaf in staff:</span>
<span class="sd">        ...     leaf, abjad.get.effective(leaf, abjad.Clef)</span>
<span class="sd">        ...</span>
<span class="sd">        (Note(&quot;c&#39;2&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>
<span class="sd">        (Note(&quot;f&#39;4&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>
<span class="sd">        (Note(&quot;g&#39;4&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>

<span class="sd">        &gt;&gt;&gt; chord = abjad.Chord(&quot;&lt;d&#39; e&#39;&gt;2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.replace(staff[0], chord)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                &lt;d&#39; e&#39;&gt;2</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                g&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; for leaf in staff:</span>
<span class="sd">        ...     leaf, abjad.get.effective(leaf, abjad.Clef)</span>
<span class="sd">        ...</span>
<span class="sd">        (Chord(&quot;&lt;d&#39; e&#39;&gt;2&quot;), None)</span>
<span class="sd">        (Note(&quot;f&#39;4&quot;), None)</span>
<span class="sd">        (Note(&quot;g&#39;4&quot;), None)</span>

<span class="sd">        &gt;&gt;&gt; abjad.wf.wellformed(staff)</span>
<span class="sd">        True</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Set ``wrappers`` to true to copy all wrappers from one leaf to</span>
<span class="sd">        another leaf (and avoid full-score update). Only works from one</span>
<span class="sd">        leaf to another leaf:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;2 f&#39;4 g&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Clef(&#39;alto&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \clef &quot;alto&quot;</span>
<span class="sd">                c&#39;2</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                g&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; for leaf in staff:</span>
<span class="sd">        ...     leaf, abjad.get.effective(leaf, abjad.Clef)</span>
<span class="sd">        ...</span>
<span class="sd">        (Note(&quot;c&#39;2&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>
<span class="sd">        (Note(&quot;f&#39;4&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>
<span class="sd">        (Note(&quot;g&#39;4&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>

<span class="sd">        &gt;&gt;&gt; chord = abjad.Chord(&quot;&lt;d&#39; e&#39;&gt;2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.replace(staff[0], chord, wrappers=True)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \clef &quot;alto&quot;</span>
<span class="sd">                &lt;d&#39; e&#39;&gt;2</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                g&#39;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; for leaf in staff:</span>
<span class="sd">        ...     leaf, abjad.get.effective(leaf, abjad.Clef)</span>
<span class="sd">        ...</span>
<span class="sd">        (Chord(&quot;&lt;d&#39; e&#39;&gt;2&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>
<span class="sd">        (Note(&quot;f&#39;4&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>
<span class="sd">        (Note(&quot;g&#39;4&quot;), Clef(name=&#39;alto&#39;, hide=False))</span>

<span class="sd">        &gt;&gt;&gt; abjad.wf.wellformed(staff)</span>
<span class="sd">        True</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        ..  todo:: Fix.</span>

<span class="sd">        Introduces duplicate ties:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;2 ~ c&#39;2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tied_notes = abjad.makers.make_notes(0, abjad.Duration(5, 8))</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.replace(staff[:1], tied_notes)</span>

<span class="sd">        &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">        &gt;&gt;&gt; print(string)</span>
<span class="sd">        \new Staff</span>
<span class="sd">        {</span>
<span class="sd">            c&#39;2</span>
<span class="sd">            ~</span>
<span class="sd">            c&#39;8</span>
<span class="sd">            c&#39;2</span>
<span class="sd">        }</span>

<span class="sd">    Returns none.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
        <span class="n">donors</span> <span class="o">=</span> <span class="p">[</span><span class="n">argument</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">donors</span> <span class="o">=</span> <span class="n">argument</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recipients</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recipients</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
            <span class="n">recipients</span> <span class="o">=</span> <span class="p">[</span><span class="n">recipients</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recipients</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">recipients</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span><span class="n">recipients</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">donors</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">wrappers</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">donors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;set wrappers only with single leaf: </span><span class="si">{</span><span class="n">donors</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">recipients</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recipients</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;set wrappers only with single leaf: </span><span class="si">{</span><span class="n">recipients</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">donor</span> <span class="o">=</span> <span class="n">donors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">wrappers</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">wrappers</span><span class="p">(</span><span class="n">donor</span><span class="p">)</span>
        <span class="n">recipient</span> <span class="o">=</span> <span class="n">recipients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">_get_parent_and_start_stop_indices</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span>
    <span class="n">parent</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">recipients</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wrappers</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">:</span>
        <span class="c1"># bypass Wrapper._bind_component()</span>
        <span class="c1"># to avoid full-score update / traversal;</span>
        <span class="c1"># this works because one-to-one leaf replacement</span>
        <span class="c1"># including all (persistent) indicators</span>
        <span class="c1"># doesn&#39;t change score structure:</span>
        <span class="n">donor</span><span class="o">.</span><span class="n">_wrappers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="n">_component</span> <span class="o">=</span> <span class="n">recipient</span>
        <span class="n">recipient</span><span class="o">.</span><span class="n">_wrappers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">_find_correct_effective_context</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">_dependent_wrappers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span></div>


<div class="viewcode-block" id="scale"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.scale">[docs]</a><span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scales ``argument`` by ``multiplier``.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Scales note duration by dot-generating multiplier:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;8 ( d&#39;8 e&#39;8 f&#39;8 )&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.scale(staff[1], abjad.Multiplier(3, 2))</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                (</span>
<span class="sd">                d&#39;8.</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                )</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Scales tied leaves by dot-generating mutliplier:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(r&quot;c&#39;8 \accent ~ c&#39;8 d&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((3, 8))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 3/8</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                - \accent</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; logical_tie = abjad.select.logical_tie(staff[0])</span>
<span class="sd">        &gt;&gt;&gt; logical_tie = abjad.mutate.scale(logical_tie, abjad.Multiplier(3, 2))</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 3/8</span>
<span class="sd">                c&#39;8.</span>
<span class="sd">                - \accent</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;8.</span>
<span class="sd">                d&#39;8</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Scales leaves in container by dot-generating multiplier:</span>

<span class="sd">        &gt;&gt;&gt; container = abjad.Container(r&quot;c&#39;8 ( d&#39;8 e&#39;8 f&#39;8 )&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(container) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(container)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                (</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                )</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.scale(container, abjad.Multiplier(3, 2))</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(container) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(container)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8.</span>
<span class="sd">                (</span>
<span class="sd">                d&#39;8.</span>
<span class="sd">                e&#39;8.</span>
<span class="sd">                f&#39;8.</span>
<span class="sd">                )</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Scales leaves in tuplet:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff()</span>
<span class="sd">        &gt;&gt;&gt; tuplet = abjad.Tuplet((4, 5), &quot;c&#39;8 d&#39;8 e&#39;8 f&#39;8 g&#39;8&quot;)</span>
<span class="sd">        &gt;&gt;&gt; staff.append(tuplet)</span>
<span class="sd">        &gt;&gt;&gt; time_signature = abjad.TimeSignature((4, 8))</span>
<span class="sd">        &gt;&gt;&gt; leaf = abjad.get.leaf(staff, 0)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(time_signature, leaf)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \times 4/5</span>
<span class="sd">                {</span>
<span class="sd">                    \time 4/8</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                    e&#39;8</span>
<span class="sd">                    f&#39;8</span>
<span class="sd">                    g&#39;8</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.scale(tuplet, abjad.Multiplier(2))</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \times 4/5</span>
<span class="sd">                {</span>
<span class="sd">                    \time 4/8</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    g&#39;4</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Scales leaves carrying LilyPond multiplier:</span>

<span class="sd">        &gt;&gt;&gt; note = abjad.Note(&quot;c&#39;8&quot;, multiplier=(1, 2))</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(note) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(note)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            c&#39;8 * 1/2</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.scale(note, abjad.Multiplier(1, 2))</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(note) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(note)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            c&#39;16 * 1/2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="s2">&quot;_scale&quot;</span><span class="p">):</span>
        <span class="n">argument</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">multiplier</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">argument</span><span class="p">:</span>
            <span class="n">component</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">multiplier</span><span class="p">)</span></div>


<span class="c1"># TODO: add tests of tupletted notes and rests.</span>
<span class="c1"># TODO: add examples that show indicator handling.</span>
<span class="c1"># TODO: add example showing grace and after grace handling.</span>
<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.split">[docs]</a><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">cyclic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits ``argument`` by ``durations``.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Splits leaves cyclically and ties split notes:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;1 d&#39;1&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, staff[:])</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(staff).DynamicLineSpanner.staff_padding = 3</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;1</span>
<span class="sd">                \p</span>
<span class="sd">                \&lt;</span>
<span class="sd">                d&#39;1</span>
<span class="sd">                \f</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; durations = [(3, 4)]</span>
<span class="sd">        &gt;&gt;&gt; result = abjad.mutate.split(</span>
<span class="sd">        ...     staff[:],</span>
<span class="sd">        ...     durations,</span>
<span class="sd">        ...     cyclic=True,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;2.</span>
<span class="sd">                \p</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                \&lt;</span>
<span class="sd">                d&#39;2</span>
<span class="sd">                \f</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;2</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Splits custom voice and preserves context name:</span>

<span class="sd">        &gt;&gt;&gt; voice = abjad.Voice(</span>
<span class="sd">        ...     &quot;c&#39;4 d&#39; e&#39; f&#39;&quot;,</span>
<span class="sd">        ...     lilypond_type=&#39;CustomVoice&#39;,</span>
<span class="sd">        ...     name=&#39;1&#39;,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff([voice])</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, voice[:])</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(staff).DynamicLineSpanner.staff_padding = 3</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; durations = [(1, 8)]</span>
<span class="sd">        &gt;&gt;&gt; result = abjad.mutate.split(</span>
<span class="sd">        ...     staff[:],</span>
<span class="sd">        ...     durations,</span>
<span class="sd">        ...     cyclic=True,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            \with</span>
<span class="sd">            {</span>
<span class="sd">                \override DynamicLineSpanner.staff-padding = 3</span>
<span class="sd">            }</span>
<span class="sd">            {</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    \p</span>
<span class="sd">                    ~</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                    ~</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    e&#39;8</span>
<span class="sd">                    ~</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    e&#39;8</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    f&#39;8</span>
<span class="sd">                    \f</span>
<span class="sd">                    ~</span>
<span class="sd">                }</span>
<span class="sd">                \context CustomVoice = &quot;1&quot;</span>
<span class="sd">                {</span>
<span class="sd">                    f&#39;8</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; for voice in staff:</span>
<span class="sd">        ...     voice</span>
<span class="sd">        ...</span>
<span class="sd">        Voice(&quot;c&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;c&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;d&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;d&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;e&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;e&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;f&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>
<span class="sd">        Voice(&quot;f&#39;8&quot;, lilypond_type=&#39;CustomVoice&#39;, name=&#39;1&#39;)</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Splits parallel container:</span>

<span class="sd">        &gt;&gt;&gt; voice_1 = abjad.Voice(</span>
<span class="sd">        ...     &quot;e&#39;&#39;4 ( es&#39;&#39; f&#39;&#39; fs&#39;&#39; )&quot;,</span>
<span class="sd">        ...     name=&#39;Voice_1&#39;,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; voice_2 = abjad.Voice(</span>
<span class="sd">        ...     r&quot;c&#39;4 \p \&lt; cs&#39; d&#39; ds&#39; \f&quot;,</span>
<span class="sd">        ...     name=&#39;Voice_2&#39;,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(voice_1).Stem.direction = abjad.UP</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(voice_1).Slur.direction = abjad.UP</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.Container(</span>
<span class="sd">        ...     [voice_1, voice_2],</span>
<span class="sd">        ...     simultaneous=True,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; abjad.override(voice_2).Stem.direction = abjad.DOWN</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff([container])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                &lt;&lt;</span>
<span class="sd">                    \context Voice = &quot;Voice_1&quot;</span>
<span class="sd">                    \with</span>
<span class="sd">                    {</span>
<span class="sd">                        \override Slur.direction = #up</span>
<span class="sd">                        \override Stem.direction = #up</span>
<span class="sd">                    }</span>
<span class="sd">                    {</span>
<span class="sd">                        e&#39;&#39;4</span>
<span class="sd">                        (</span>
<span class="sd">                        es&#39;&#39;4</span>
<span class="sd">                        f&#39;&#39;4</span>
<span class="sd">                        fs&#39;&#39;4</span>
<span class="sd">                        )</span>
<span class="sd">                    }</span>
<span class="sd">                    \context Voice = &quot;Voice_2&quot;</span>
<span class="sd">                    \with</span>
<span class="sd">                    {</span>
<span class="sd">                        \override Stem.direction = #down</span>
<span class="sd">                    }</span>
<span class="sd">                    {</span>
<span class="sd">                        c&#39;4</span>
<span class="sd">                        \p</span>
<span class="sd">                        \&lt;</span>
<span class="sd">                        cs&#39;4</span>
<span class="sd">                        d&#39;4</span>
<span class="sd">                        ds&#39;4</span>
<span class="sd">                        \f</span>
<span class="sd">                    }</span>
<span class="sd">                &gt;&gt;</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; durations = [(3, 8)]</span>
<span class="sd">        &gt;&gt;&gt; result = abjad.mutate.split(</span>
<span class="sd">        ...     container,</span>
<span class="sd">        ...     durations,</span>
<span class="sd">        ...     cyclic=False,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">        &gt;&gt;&gt; print(string)</span>
<span class="sd">        \new Staff</span>
<span class="sd">        {</span>
<span class="sd">            &lt;&lt;</span>
<span class="sd">                \context Voice = &quot;Voice_1&quot;</span>
<span class="sd">                \with</span>
<span class="sd">                {</span>
<span class="sd">                    \override Slur.direction = #up</span>
<span class="sd">                    \override Stem.direction = #up</span>
<span class="sd">                }</span>
<span class="sd">                {</span>
<span class="sd">                    e&#39;&#39;4</span>
<span class="sd">                    (</span>
<span class="sd">                    es&#39;&#39;8</span>
<span class="sd">                    ~</span>
<span class="sd">                }</span>
<span class="sd">                \context Voice = &quot;Voice_2&quot;</span>
<span class="sd">                \with</span>
<span class="sd">                {</span>
<span class="sd">                    \override Stem.direction = #down</span>
<span class="sd">                }</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    cs&#39;8</span>
<span class="sd">                    ~</span>
<span class="sd">                }</span>
<span class="sd">            &gt;&gt;</span>
<span class="sd">            &lt;&lt;</span>
<span class="sd">                \context Voice = &quot;Voice_1&quot;</span>
<span class="sd">                \with</span>
<span class="sd">                {</span>
<span class="sd">                    \override Slur.direction = #up</span>
<span class="sd">                    \override Stem.direction = #up</span>
<span class="sd">                }</span>
<span class="sd">                {</span>
<span class="sd">                    es&#39;&#39;8</span>
<span class="sd">                    f&#39;&#39;4</span>
<span class="sd">                    fs&#39;&#39;4</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">                \context Voice = &quot;Voice_2&quot;</span>
<span class="sd">                \with</span>
<span class="sd">                {</span>
<span class="sd">                    \override Stem.direction = #down</span>
<span class="sd">                }</span>
<span class="sd">                {</span>
<span class="sd">                    cs&#39;8</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    ds&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                }</span>
<span class="sd">            &gt;&gt;</span>
<span class="sd">        }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Splits leaves with articulations:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;4 d&#39; e&#39; f&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Articulation(&#39;^&#39;), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.LaissezVibrer(), staff[1])</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.Articulation(&#39;^&#39;), staff[2])</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.LaissezVibrer(), staff[3])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                - \marcato</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                \laissezVibrer</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                - \marcato</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                \laissezVibrer</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; durations = [(1, 8)]</span>
<span class="sd">        &gt;&gt;&gt; result = abjad.mutate.split(</span>
<span class="sd">        ...     staff[:],</span>
<span class="sd">        ...     durations,</span>
<span class="sd">        ...     cyclic=True,</span>
<span class="sd">        ...     )</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                - \marcato</span>
<span class="sd">                ~</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                \laissezVibrer</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                - \marcato</span>
<span class="sd">                ~</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                ~</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                \laissezVibrer</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        REGRESSION. Preserves tie:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;d&#39;2 ~ d&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                d&#39;2</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;2</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; result = abjad.mutate.split(staff[0], [(1, 32)])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                d&#39;32</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;4...</span>
<span class="sd">                ~</span>
<span class="sd">                d&#39;2</span>
<span class="sd">            }</span>

<span class="sd">    Returns list of selections.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">argument</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">components</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">components</span><span class="p">)</span>
    <span class="n">durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">durations</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">durations</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
    <span class="n">total_component_duration</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">duration</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
    <span class="n">total_split_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cyclic</span><span class="p">:</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">repeat_to_weight</span><span class="p">(</span><span class="n">durations</span><span class="p">,</span> <span class="n">total_component_duration</span><span class="p">)</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">total_split_duration</span> <span class="o">&lt;</span> <span class="n">total_component_duration</span><span class="p">:</span>
        <span class="n">final_offset</span> <span class="o">=</span> <span class="n">total_component_duration</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
        <span class="n">durations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_offset</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">total_component_duration</span> <span class="o">&lt;</span> <span class="n">total_split_duration</span><span class="p">:</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">total_component_duration</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">durations</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
    <span class="c1"># keep copy of durations to partition result components</span>
    <span class="n">durations_copy</span> <span class="o">=</span> <span class="n">durations</span><span class="p">[:]</span>
    <span class="n">total_split_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">durations</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">total_split_duration</span> <span class="o">==</span> <span class="n">total_component_duration</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">shard</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">offset_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">current_shard_duration</span> <span class="o">=</span> <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">remaining_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="p">[:])</span>
    <span class="n">advance_to_next_offset</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># build shards:</span>
    <span class="c1"># grab next component and next duration each time through loop</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># grab next split point</span>
        <span class="k">if</span> <span class="n">advance_to_next_offset</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">durations</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">next_split_point</span> <span class="o">=</span> <span class="n">durations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">advance_to_next_offset</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># grab next component from input stack of components</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining_components</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">current_component</span> <span class="o">=</span> <span class="n">remaining_components</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># find where current component endpoint will position us</span>
        <span class="n">duration_</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">duration</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>
        <span class="n">candidate_shard_duration</span> <span class="o">=</span> <span class="n">current_shard_duration</span> <span class="o">+</span> <span class="n">duration_</span>
        <span class="c1"># if current component would fill current shard exactly</span>
        <span class="k">if</span> <span class="n">candidate_shard_duration</span> <span class="o">==</span> <span class="n">next_split_point</span><span class="p">:</span>
            <span class="n">shard</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shard</span><span class="p">)</span>
            <span class="n">shard</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_shard_duration</span> <span class="o">=</span> <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">offset_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># if current component would exceed current shard</span>
        <span class="k">elif</span> <span class="n">next_split_point</span> <span class="o">&lt;</span> <span class="n">candidate_shard_duration</span><span class="p">:</span>
            <span class="n">local_split_duration</span> <span class="o">=</span> <span class="n">next_split_point</span>
            <span class="n">local_split_duration</span> <span class="o">-=</span> <span class="n">current_shard_duration</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_component</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Leaf</span><span class="p">):</span>
                <span class="n">leaf_split_durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">local_split_duration</span><span class="p">]</span>
                <span class="n">duration_</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">duration</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>
                <span class="n">current_duration</span> <span class="o">=</span> <span class="n">duration_</span>
                <span class="n">additional_required_duration</span> <span class="o">=</span> <span class="n">current_duration</span>
                <span class="n">additional_required_duration</span> <span class="o">-=</span> <span class="n">local_split_duration</span>
                <span class="n">split_durations</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                    <span class="n">durations</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">additional_required_duration</span><span class="p">],</span>
                    <span class="n">cyclic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">overhang</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">split_durations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">split_durations</span><span class="p">]</span>
                <span class="n">additional_durations</span> <span class="o">=</span> <span class="n">split_durations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">leaf_split_durations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">additional_durations</span><span class="p">)</span>
                <span class="n">durations</span> <span class="o">=</span> <span class="n">split_durations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">leaf_shards</span> <span class="o">=</span> <span class="n">_split_leaf_by_durations</span><span class="p">(</span>
                    <span class="n">current_component</span><span class="p">,</span>
                    <span class="n">leaf_split_durations</span><span class="p">,</span>
                    <span class="n">cyclic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">shard</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">leaf_shards</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shard</span><span class="p">)</span>
                <span class="n">offset_index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">additional_durations</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_component</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">_split_container_by_duration</span><span class="p">(</span>
                    <span class="n">current_component</span><span class="p">,</span>
                    <span class="n">local_split_duration</span><span class="p">,</span>
                    <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">left_list</span><span class="p">,</span> <span class="n">right_list</span> <span class="o">=</span> <span class="n">pair</span>
                <span class="n">shard</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left_list</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shard</span><span class="p">)</span>
                <span class="n">remaining_components</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">right_list</span><span class="p">)</span>
            <span class="n">shard</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">offset_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current_shard_duration</span> <span class="o">=</span> <span class="n">_duration</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># if current component would not fill current shard</span>
        <span class="k">elif</span> <span class="n">candidate_shard_duration</span> <span class="o">&lt;</span> <span class="n">next_split_point</span><span class="p">:</span>
            <span class="n">shard</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>
            <span class="n">duration_</span> <span class="o">=</span> <span class="n">_get</span><span class="o">.</span><span class="n">duration</span><span class="p">(</span><span class="n">current_component</span><span class="p">)</span>
            <span class="n">current_shard_duration</span> <span class="o">+=</span> <span class="n">duration_</span>
            <span class="n">advance_to_next_offset</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;can not process candidate duration: </span><span class="si">{!r}</span><span class="s2">.&quot;</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">candidate_shard_duration</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="c1"># append any stub shard</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shard</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shard</span><span class="p">)</span>
    <span class="c1"># append any unexamined components</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_components</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">remaining_components</span><span class="p">)</span>
    <span class="c1"># partition split components according to input durations</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_sequence</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_select</span><span class="o">.</span><span class="n">partition_by_durations</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">durations_copy</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">_enums</span><span class="o">.</span><span class="n">EXACT</span><span class="p">)</span>
    <span class="c1"># return list of shards</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="swap"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.swap">[docs]</a><span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ``argument`` for empty ``container``.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Swaps containers for tuplet:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff()</span>
<span class="sd">        &gt;&gt;&gt; staff.append(abjad.Container(&quot;c&#39;4 d&#39;4 e&#39;4&quot;))</span>
<span class="sd">        &gt;&gt;&gt; staff.append(abjad.Container(&quot;d&#39;4 e&#39;4 f&#39;4&quot;))</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.TimeSignature((3, 4)), staff[0][0])</span>
<span class="sd">        &gt;&gt;&gt; leaves = abjad.select.leaves(staff)</span>
<span class="sd">        &gt;&gt;&gt; abjad.hairpin(&#39;p &lt; f&#39;, leaves)</span>
<span class="sd">        &gt;&gt;&gt; measures = staff[:]</span>
<span class="sd">        &gt;&gt;&gt; abjad.slur(leaves)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                {</span>
<span class="sd">                    \time 3/4</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    (</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                }</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; containers = staff[:]</span>
<span class="sd">        &gt;&gt;&gt; tuplet = abjad.Tuplet((2, 3), [])</span>
<span class="sd">        &gt;&gt;&gt; tuplet.denominator = 4</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.swap(containers, tuplet)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \times 4/6</span>
<span class="sd">                {</span>
<span class="sd">                    \time 3/4</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    \p</span>
<span class="sd">                    (</span>
<span class="sd">                    \&lt;</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                    \f</span>
<span class="sd">                    )</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">    Returns none.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">donors</span> <span class="o">=</span> <span class="n">argument</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">)</span>
        <span class="n">donors</span> <span class="o">=</span> <span class="p">[</span><span class="n">argument</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">_are_contiguous_same_parent</span><span class="p">(</span><span class="n">donors</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">container</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
    <span class="n">_give_components_to_empty_container</span><span class="p">(</span><span class="n">donors</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">_give_position_in_parent_to_container</span><span class="p">(</span><span class="n">donors</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span></div>


<div class="viewcode-block" id="transpose"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.transpose">[docs]</a><span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes notes and chords in ``argument`` by ``interval``.</span>

<span class="sd">    ..  todo:: Move to abjad.pitch package.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Transposes notes and chords in staff:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff()</span>
<span class="sd">        &gt;&gt;&gt; staff.extend(&quot;c&#39;4 d&#39;4 e&#39;4 r4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.TimeSignature((4, 4)), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; staff.extend(&quot;d&#39;4 e&#39;4 &lt;f&#39; a&#39; c&#39;&#39;&gt;4&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.TimeSignature((3, 4)), staff[4])</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 4/4</span>
<span class="sd">                c&#39;4</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                r4</span>
<span class="sd">                \time 3/4</span>
<span class="sd">                d&#39;4</span>
<span class="sd">                e&#39;4</span>
<span class="sd">                &lt;f&#39; a&#39; c&#39;&#39;&gt;4</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; abjad.mutate.transpose(staff, &quot;+m3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \time 4/4</span>
<span class="sd">                ef&#39;4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                g&#39;4</span>
<span class="sd">                r4</span>
<span class="sd">                \time 3/4</span>
<span class="sd">                f&#39;4</span>
<span class="sd">                g&#39;4</span>
<span class="sd">                &lt;af&#39; c&#39;&#39; ef&#39;&#39;&gt;4</span>
<span class="sd">            }</span>

<span class="sd">    Returns none.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">named_interval</span> <span class="o">=</span> <span class="n">_pitch</span><span class="o">.</span><span class="n">NamedInterval</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">_iterate</span><span class="o">.</span><span class="n">components</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="p">(</span><span class="n">_score</span><span class="o">.</span><span class="n">Note</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Chord</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Note</span><span class="p">):</span>
            <span class="n">old_written_pitch</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">note_head</span><span class="o">.</span><span class="n">written_pitch</span>
            <span class="n">new_written_pitch</span> <span class="o">=</span> <span class="n">old_written_pitch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">named_interval</span><span class="p">)</span>
            <span class="n">item</span><span class="o">.</span><span class="n">note_head</span><span class="o">.</span><span class="n">written_pitch</span> <span class="o">=</span> <span class="n">new_written_pitch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">note_head</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">note_heads</span><span class="p">:</span>
                <span class="n">old_written_pitch</span> <span class="o">=</span> <span class="n">note_head</span><span class="o">.</span><span class="n">written_pitch</span>
                <span class="n">new_written_pitch</span> <span class="o">=</span> <span class="n">old_written_pitch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">named_interval</span><span class="p">)</span>
                <span class="n">note_head</span><span class="o">.</span><span class="n">written_pitch</span> <span class="o">=</span> <span class="n">new_written_pitch</span></div>


<div class="viewcode-block" id="wrap"><a class="viewcode-back" href="../../api/abjad/mutate.html#abjad.mutate.wrap">[docs]</a><span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps ``argument`` in empty ``container``.</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Wraps in-score notes in tuplet:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;8 [ ( d&#39; e&#39; ] ) c&#39; [ ( d&#39; e&#39; ] )&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                [</span>
<span class="sd">                (</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                )</span>
<span class="sd">                ]</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                [</span>
<span class="sd">                (</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                )</span>
<span class="sd">                ]</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; tuplet = abjad.Tuplet((2, 3), [])</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.wrap(staff[-3:], tuplet)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                [</span>
<span class="sd">                (</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                )</span>
<span class="sd">                ]</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    [</span>
<span class="sd">                    (</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                    e&#39;8</span>
<span class="sd">                    )</span>
<span class="sd">                    ]</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Wraps outside-score notes in tuplet:</span>

<span class="sd">        &gt;&gt;&gt; notes = abjad.makers.make_notes([0, 2, 4], [(1, 8)])</span>
<span class="sd">        &gt;&gt;&gt; tuplet = abjad.Tuplet((2, 3), [])</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.wrap(notes, tuplet)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(tuplet) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(tuplet)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \times 2/3</span>
<span class="sd">            {</span>
<span class="sd">                c&#39;8</span>
<span class="sd">                d&#39;8</span>
<span class="sd">                e&#39;8</span>
<span class="sd">            }</span>

<span class="sd">        (This usage merely substitutes for the tuplet initializer.)</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Wraps leaves in container:</span>

<span class="sd">        &gt;&gt;&gt; notes = [abjad.Note(n, (1, 8)) for n in range(8)]</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(notes)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.TimeSignature((4, 8)), staff[0])</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.Container()</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.wrap(staff[:4], container)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                {</span>
<span class="sd">                    \time 4/8</span>
<span class="sd">                    c&#39;8</span>
<span class="sd">                    cs&#39;8</span>
<span class="sd">                    d&#39;8</span>
<span class="sd">                    ef&#39;8</span>
<span class="sd">                }</span>
<span class="sd">                e&#39;8</span>
<span class="sd">                f&#39;8</span>
<span class="sd">                fs&#39;8</span>
<span class="sd">                g&#39;8</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Wraps each leaf in tuplet:</span>

<span class="sd">        &gt;&gt;&gt; notes = [abjad.Note(n, (1, 1)) for n in range(4)]</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(notes)</span>
<span class="sd">        &gt;&gt;&gt; for note in staff:</span>
<span class="sd">        ...     tuplet = abjad.Tuplet((2, 3))</span>
<span class="sd">        ...     abjad.mutate.wrap(note, tuplet)</span>
<span class="sd">        ...</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                \tweak edge-height #&#39;(0.7 . 0)</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    c&#39;1</span>
<span class="sd">                }</span>
<span class="sd">                \tweak edge-height #&#39;(0.7 . 0)</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    cs&#39;1</span>
<span class="sd">                }</span>
<span class="sd">                \tweak edge-height #&#39;(0.7 . 0)</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    d&#39;1</span>
<span class="sd">                }</span>
<span class="sd">                \tweak edge-height #&#39;(0.7 . 0)</span>
<span class="sd">                \times 2/3</span>
<span class="sd">                {</span>
<span class="sd">                    ef&#39;1</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        Raises exception on nonempty ``container``:</span>

<span class="sd">        &gt;&gt;&gt; import pytest</span>
<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;8 [ ( d&#39; e&#39; ] ) c&#39; [ ( d&#39; e&#39; ] )&quot;)</span>
<span class="sd">        &gt;&gt;&gt; tuplet = abjad.Tuplet((2, 3), &quot;g&#39;8 a&#39; fs&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.wrap(staff[-3:], tuplet)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        Exception: must be empty container: Tuplet(&#39;3:2&#39;, &quot;g&#39;8 a&#39;8 fs&#39;8&quot;).</span>

<span class="sd">    ..  container:: example</span>

<span class="sd">        REGRESSION. Contexted indicators (like time signature) survive</span>
<span class="sd">        wrap:</span>

<span class="sd">        &gt;&gt;&gt; staff = abjad.Staff(&quot;c&#39;4 d&#39; e&#39; f&#39;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; leaves = abjad.select.leaves(staff)</span>
<span class="sd">        &gt;&gt;&gt; abjad.attach(abjad.TimeSignature((3, 8)), leaves[0])</span>
<span class="sd">        &gt;&gt;&gt; container = abjad.Container()</span>
<span class="sd">        &gt;&gt;&gt; abjad.mutate.wrap(leaves, container)</span>
<span class="sd">        &gt;&gt;&gt; abjad.show(staff) # doctest: +SKIP</span>

<span class="sd">        ..  docs::</span>

<span class="sd">            &gt;&gt;&gt; string = abjad.lilypond(staff)</span>
<span class="sd">            &gt;&gt;&gt; print(string)</span>
<span class="sd">            \new Staff</span>
<span class="sd">            {</span>
<span class="sd">                {</span>
<span class="sd">                    \time 3/8</span>
<span class="sd">                    c&#39;4</span>
<span class="sd">                    d&#39;4</span>
<span class="sd">                    e&#39;4</span>
<span class="sd">                    f&#39;4</span>
<span class="sd">                }</span>
<span class="sd">            }</span>

<span class="sd">        &gt;&gt;&gt; prototype = abjad.TimeSignature</span>
<span class="sd">        &gt;&gt;&gt; for component in abjad.iterate.components(staff):</span>
<span class="sd">        ...     time_signature = abjad.get.effective(component, prototype)</span>
<span class="sd">        ...     print(component, time_signature)</span>
<span class="sd">        ...</span>
<span class="sd">        Staff(&quot;{ c&#39;4 d&#39;4 e&#39;4 f&#39;4 }&quot;) TimeSignature(pair=(3, 8), hide=False, partial=None)</span>
<span class="sd">        Container(&quot;c&#39;4 d&#39;4 e&#39;4 f&#39;4&quot;) TimeSignature(pair=(3, 8), hide=False, partial=None)</span>
<span class="sd">        Note(&quot;c&#39;4&quot;) TimeSignature(pair=(3, 8), hide=False, partial=None)</span>
<span class="sd">        Note(&quot;d&#39;4&quot;) TimeSignature(pair=(3, 8), hide=False, partial=None)</span>
<span class="sd">        Note(&quot;e&#39;4&quot;) TimeSignature(pair=(3, 8), hide=False, partial=None)</span>
<span class="sd">        Note(&quot;f&#39;4&quot;) TimeSignature(pair=(3, 8), hide=False, partial=None)</span>

<span class="sd">    Returns none.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Container</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;must be empty container: </span><span class="si">{</span><span class="n">container</span><span class="si">!r}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">_score</span><span class="o">.</span><span class="n">Component</span><span class="p">):</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="p">[</span><span class="n">argument</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">argument</span>
    <span class="n">parent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">_get_parent_and_start_stop_indices</span><span class="p">(</span>
        <span class="n">selection</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_are_contiguous_logical_voice</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">ignore_before_after_grace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;must be contiguous components in same logical voice:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">message</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">selection</span><span class="si">!r}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">container</span><span class="o">.</span><span class="n">_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="n">_set_parents</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">_components</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
        <span class="n">container</span><span class="o">.</span><span class="n">_set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">component</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">:</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">_effective_context</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">_update_effective_context</span><span class="p">()</span></div>
</pre></div>

    </div>
    
    </div>
    

<footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

</div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>